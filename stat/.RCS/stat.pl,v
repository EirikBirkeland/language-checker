head	1.56;
access;
symbols;
locks
	eb:1.56; strict;
comment	@# @;
expand	@o@;


1.56
date	2015.02.02.02.20.14;	author eb;	state Exp;
branches;
next	1.55;

1.55
date	2015.02.02.02.19.43;	author eb;	state Exp;
branches;
next	1.54;

1.54
date	2015.02.02.02.14.35;	author eb;	state Exp;
branches;
next	1.53;

1.53
date	2015.02.02.02.14.00;	author eb;	state Exp;
branches;
next	1.52;

1.52
date	2015.02.02.02.12.54;	author eb;	state Exp;
branches;
next	1.51;

1.51
date	2015.02.02.02.10.35;	author eb;	state Exp;
branches;
next	1.50;

1.50
date	2015.02.02.02.10.27;	author eb;	state Exp;
branches;
next	1.49;

1.49
date	2015.02.02.02.08.44;	author eb;	state Exp;
branches;
next	1.48;

1.48
date	2015.02.02.02.06.40;	author eb;	state Exp;
branches;
next	1.47;

1.47
date	2015.02.02.02.05.33;	author eb;	state Exp;
branches;
next	1.46;

1.46
date	2015.02.02.02.05.25;	author eb;	state Exp;
branches;
next	1.45;

1.45
date	2015.02.02.02.05.14;	author eb;	state Exp;
branches;
next	1.44;

1.44
date	2015.02.02.02.05.06;	author eb;	state Exp;
branches;
next	1.43;

1.43
date	2015.02.02.02.03.38;	author eb;	state Exp;
branches;
next	1.42;

1.42
date	2015.02.02.02.03.33;	author eb;	state Exp;
branches;
next	1.41;

1.41
date	2015.02.02.02.03.19;	author eb;	state Exp;
branches;
next	1.40;

1.40
date	2015.02.02.02.03.07;	author eb;	state Exp;
branches;
next	1.39;

1.39
date	2015.02.02.02.02.07;	author eb;	state Exp;
branches;
next	1.38;

1.38
date	2015.02.02.02.01.38;	author eb;	state Exp;
branches;
next	1.37;

1.37
date	2015.02.02.02.00.53;	author eb;	state Exp;
branches;
next	1.36;

1.36
date	2015.02.02.01.59.07;	author eb;	state Exp;
branches;
next	1.35;

1.35
date	2015.02.02.01.59.06;	author eb;	state Exp;
branches;
next	1.34;

1.34
date	2015.02.02.01.58.34;	author eb;	state Exp;
branches;
next	1.33;

1.33
date	2015.02.02.01.58.27;	author eb;	state Exp;
branches;
next	1.32;

1.32
date	2015.02.02.01.58.02;	author eb;	state Exp;
branches;
next	1.31;

1.31
date	2015.02.02.01.57.37;	author eb;	state Exp;
branches;
next	1.30;

1.30
date	2015.02.02.01.56.58;	author eb;	state Exp;
branches;
next	1.29;

1.29
date	2015.02.02.01.56.49;	author eb;	state Exp;
branches;
next	1.28;

1.28
date	2015.02.02.01.56.36;	author eb;	state Exp;
branches;
next	1.27;

1.27
date	2015.02.02.01.55.45;	author eb;	state Exp;
branches;
next	1.26;

1.26
date	2015.02.02.01.55.28;	author eb;	state Exp;
branches;
next	1.25;

1.25
date	2015.02.02.01.55.09;	author eb;	state Exp;
branches;
next	1.24;

1.24
date	2015.02.02.01.48.45;	author eb;	state Exp;
branches;
next	1.23;

1.23
date	2015.02.02.01.48.01;	author eb;	state Exp;
branches;
next	1.22;

1.22
date	2015.02.02.01.47.13;	author eb;	state Exp;
branches;
next	1.21;

1.21
date	2015.02.02.01.43.49;	author eb;	state Exp;
branches;
next	1.20;

1.20
date	2015.02.02.01.42.35;	author eb;	state Exp;
branches;
next	1.19;

1.19
date	2015.02.02.01.40.18;	author eb;	state Exp;
branches;
next	1.18;

1.18
date	2015.02.02.01.39.25;	author eb;	state Exp;
branches;
next	1.17;

1.17
date	2015.02.02.01.38.28;	author eb;	state Exp;
branches;
next	1.16;

1.16
date	2015.02.02.01.37.07;	author eb;	state Exp;
branches;
next	1.15;

1.15
date	2015.02.01.18.12.10;	author eb;	state Exp;
branches;
next	1.14;

1.14
date	2015.02.01.15.42.27;	author eb;	state Exp;
branches;
next	1.13;

1.13
date	2015.02.01.15.40.56;	author eb;	state Exp;
branches;
next	1.12;

1.12
date	2015.02.01.15.39.52;	author eb;	state Exp;
branches;
next	1.11;

1.11
date	2015.02.01.15.21.26;	author eb;	state Exp;
branches;
next	1.10;

1.10
date	2015.02.01.15.19.06;	author eb;	state Exp;
branches;
next	1.9;

1.9
date	2015.02.01.15.16.16;	author eb;	state Exp;
branches;
next	1.8;

1.8
date	2015.02.01.15.16.02;	author eb;	state Exp;
branches;
next	1.7;

1.7
date	2015.02.01.15.15.04;	author eb;	state Exp;
branches;
next	1.6;

1.6
date	2015.02.01.15.14.58;	author eb;	state Exp;
branches;
next	1.5;

1.5
date	2015.02.01.15.14.53;	author eb;	state Exp;
branches;
next	1.4;

1.4
date	2015.02.01.15.14.29;	author eb;	state Exp;
branches;
next	1.3;

1.3
date	2015.02.01.15.13.54;	author eb;	state Exp;
branches;
next	1.2;

1.2
date	2015.02.01.15.13.44;	author eb;	state Exp;
branches;
next	1.1;

1.1
date	2015.02.01.15.11.19;	author eb;	state Exp;
branches;
next	;


desc
@vim
@


1.56
log
@vim
@
text
@#!/usr/bin/env perl
use feature 'say';
use File::stat;
use Data::Printer;

use File::ChangeNotify;
my $watcher = File::ChangeNotify->instantiate_watcher(
    directories => ['./'],
    filter      => qr/\.(?:pl|xlf|txt)$/,
);

my @@xlfs = <*.xlf>;
foreach my $xlf (@@xlfs) {
    chomp;
    $hash{$xlf} = stat($xlf)->mtime;
}
p %hash;

# If any change is made to folder, do stuff between braces.
while ( my @@events = $watcher->wait_for_events() ) {
    say "Something has changed, running QA on updated (or new) XLFs.";
    my @@xlfs_changed = <*.xlf>;
    foreach $xlf (@@xlfs_changed) {
        my $xlf_ctime = stat($xlf)->mtime;
        if ( $xlf_ctime != $hash{$xlf} ) {
            say "The old ctime is $hash{$xlf}, and the new one is $xlf_ctime";
            say "Since the mtime has changed, we will now run QA";

            # Run QA on changed file
            system("chk $xlf");

            # Update the hash so that it doesn't run more times for no reason
            $hash{$xlf} = $xlf_ctime;
        }
    }
}

# Reminder: atime - pointer to the file's datablocks & field's data is read.
#           mtime - file's data is changed
#           ctime - the file's inode is changed

# If any change in folder happens (command for this?) then make new hash and compare keys. Do tests for those files that have changed, AND any new files.

## Dunno how to use:
## if ( my @@events = $watcher->new_events() ) { ... }
@


1.55
log
@vim
@
text
@d1 1
a1 1
#!/bin/
@


1.54
log
@vim
@
text
@d1 1
@


1.53
log
@vim
@
text
@d11 1
a11 1
y @@xlfs = <*.xlf>;
@


1.52
log
@vim
@
text
@d42 1
a42 1
#
a44 1
m
@


1.51
log
@vim
@
text
@d11 1
a11 3
## Dunno how to use:
## if ( my @@events = $watcher->new_events() ) { ... }
my @@xlfs = <*.xlf>;
d42 4
@


1.50
log
@vim
@
text
@d29 6
a34 4
# Run QA on changed file           
 system("chk $xlf");
# Update the hash so that it doesn't run more times for no reason
$hash{$xlf} = $xlf_ctime;             
d38 1
@


1.49
log
@vim
@
text
@d29 4
a32 1
            system("chk $xlf");
@


1.48
log
@vim
@
text
@d29 1
a29 1
            system(chk $xlf);
@


1.47
log
@vim
@
text
@d28 2
@


1.46
log
@vim
@
text
@a30 1
asdfaklsjdflÃ¸akjdflkajdlkfj                     asdfajlsdfjalskdjfalskdjasldfjakl                  
@


1.45
log
@vim
@
text
@d31 1
a31 1
                     asdfajlsdfjalskdjfalskdjasldfjakl                  
@


1.44
log
@vim
@
text
@d31 1
a31 1
                                       
@


1.43
log
@vim
@
text
@d31 1
a31 1
                    
@


1.42
log
@vim
@
text
@d31 1
a31 1
          
@


1.41
log
@vim
@
text
@d31 1
a31 1

@


1.40
log
@vim
@
text
@a29 1

@


1.39
log
@vim
@
text
@d27 1
a27 1
            say "The old ctime is $hash{$xlf}, and the new one is $xlf_mtime";
@


1.38
log
@vim
@
text
@d8 1
a8 1
    filter      => qr/\.(?:pl|xml|txt)$/,
@


1.37
log
@vim
@
text
@d27 1
a27 1
            say "The old ctime is $hash{$xlf}, and the new one is $xlf_ctime";
@


1.36
log
@vim
@
text
@d16 1
a16 1
    $hash{$xlf} = stat($xlf)->ctime;
d25 1
a25 1
        my $xlf_ctime = stat($xlf)->ctime;
@


1.35
log
@vim
@
text
@d26 3
a28 3
        if ($xlf_ctime != $hash{$xlf} ) {
              say "The old ctime is $hash{$xlf}, and the new one is $xlf_ctime";
        };
@


1.34
log
@vim
@
text
@d26 1
a26 1
        if $xlf_ctime != $hash{$xlf} ) {
@


1.33
log
@vim
@
text
@d25 1
a25 1
        my $xlf_ctime = "test"; # stat($xlf)->ctime;
@


1.32
log
@vim
@
text
@d24 2
a25 2
    foreach$xlf (@@xlfs_changed) {
        my $xlf_ctime = stat($xlf)->ctime;
@


1.31
log
@vim
@
text
@d24 1
a24 1
    foreach my $xlf (@@xlfs_changed) {
d26 1
a26 2
        if $xlf_ctime != $hash{$xlf} )
          {
d28 1
a28 1
        }
@


1.30
log
@vim
@
text
@d25 1
a25 4
## Please see file perltidy.ERR
## Please see file perltidy.ERR
## Please see file perltidy.ERR
        my $xlf_ctime = stat $xlf->ctime;
@


1.29
log
@vim
@
text
@d27 4
a30 2
        my $xlf_ctime = stat $xlf->ctime ;
        if $xlf_ctime != $hash{$xlf} ) {
d32 1
a32 1
        };
@


1.28
log
@vim
@
text
@d26 2
a27 1
        my $xlf_ctime = stat ( $xlf->ctime );
@


1.27
log
@vim
@
text
@d24 3
a26 2
    foreach my $xlf(@@xlfs_changed) {
        my $xlf_ctime = stat( $xlf->ctime );
d29 1
a29 1
        }
@


1.26
log
@vim
@
text
@d24 1
a24 1
    foreach my $xlf (@@xlfs_changed) {
d28 1
a28 1
        };
@


1.25
log
@vim
@
text
@d24 6
a29 7
    foreach my $xlf(@@xlfs_changed){
my $xlf_ctime = stat($xlf->ctime);

if $xlf_ctime != $hash{$xlf}) {
say "The old ctime is $hash{$xlf}, and the new one is $xlf_ctime";
}
      }
a37 2

lol
@


1.24
log
@vim
@
text
@d14 1
a14 1
foreach my $file (@@xlfs) {
d16 1
a16 1
    $hash{$file} = stat($file)->ctime;
d22 4
a25 5
  say "Something has changed, running QA on updated (or new) XLFs.";
  my @@xlfs_changed = <*.xlf>;    
foreach @@xlfs_changed {


d27 2
d30 1
@


1.23
log
@vim
@
text
@d23 2
a24 1
  @@files = <*.xlf>;    
d26 3
@


1.22
log
@vim
@
text
@d13 2
a14 2

foreach my $file (<*.xlf>) {
@


1.21
log
@vim
@
text
@d6 4
a9 5
my $watcher =
    File::ChangeNotify->instantiate_watcher
        ( directories => [ './' ],
          filter      => qr/\.(?:pl|xml|txt)$/,
        );
d11 1
a11 1
## Dunno how to use: 
d14 1
a14 1
foreach my $file(@@ARGV) {
d22 2
a23 1
print "\nA file or folder has changed\n" }
d26 1
a32 1

@


1.20
log
@vim
@
text
@a14 7
# If any change is made to folder, do stuff between braces.
while ( my @@events = $watcher->wait_for_events() ) { print "\nA file or folder has changed\n" }

# Reminder: atime - pointer to the file's datablocks & field's data is read.
#           mtime - file's data is changed
#           ctime - the file's inode is changed

d21 5
d27 3
@


1.19
log
@vim
@
text
@d22 1
a22 1
foreach (@@ARGV) {
d24 1
a24 1
    $hash{$_} = stat($_)->ctime;
@


1.18
log
@vim
@
text
@d16 1
a16 1
#while ( my @@events = $watcher->wait_for_events() ) { print "\nA file or folder has changed\n" }
@


1.17
log
@vim
@
text
@d16 1
a16 1
while ( my @@events = $watcher->wait_for_events() ) { print "\nA file or folder has changed\n" }
@


1.16
log
@vim
@
text
@d9 1
a9 1
          filter      => qr/\.(?:pm|conf|yml)$/,
@


1.15
log
@vim
@
text
@d12 2
a13 2
# Dunno how to use: 
# if ( my @@events = $watcher->new_events() ) { ... }
@


1.14
log
@vim
@
text
@d16 5
a20 1
while ( my @@events = $watcher->wait_for_events() ) { print "\nA file has changed\n" }
d24 1
a24 1
    $hash{$_} = stat($_)->atime;
@


1.13
log
@vim
@
text
@d11 5
a15 2
 
if ( my @@events = $watcher->new_events() ) { ... }
@


1.12
log
@vim
@
text
@d23 1
a23 1
# If any change in folder happens (command for this?) then make new hash and compare keys. Do tests for those files that have changed, and any new files.
@


1.11
log
@(rcsvers.vim) modified outside of vim.
@
text
@d4 11
d17 1
a17 1
    $hash{$_} = stat($_)->size;
d20 2
@


1.10
log
@vim
@
text
@d13 1
@


1.9
log
@vim
@
text
@d9 4
@


1.8
log
@vim
@
text
@a3 1
my %hash;
d8 1
a8 1
p @@array;
@


1.7
log
@vim
@
text
@d6 2
a7 2
chomp;
$hash{$_} = stat($_)->size;
@


1.6
log
@vim
@
text
@d6 1
a6 1
    chomp;
@


1.5
log
@vim
@
text
@d4 1
a4 1
%hash;
@


1.4
log
@vim
@
text
@d4 1
@


1.3
log
@vim
@
text
@d6 1
a6 1
   push (@@array, stat($_)->size);
@


1.2
log
@vim
@
text
@d3 1
a3 1
use File::Printer;
@


1.1
log
@vim
@
text
@d3 1
d6 1
a6 1
    say stat($_)->size;
d8 1
@
