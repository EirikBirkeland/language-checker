head	1.18;
access;
symbols;
locks
	eb:1.18; strict;
comment	@# @;
expand	@o@;


1.18
date	2015.03.11.09.55.01;	author eb;	state Exp;
branches;
next	1.17;

1.17
date	2015.03.11.09.54.46;	author eb;	state Exp;
branches;
next	1.16;

1.16
date	2015.03.11.09.53.51;	author eb;	state Exp;
branches;
next	1.15;

1.15
date	2015.03.09.19.03.30;	author eb;	state Exp;
branches;
next	1.14;

1.14
date	2015.03.09.19.02.35;	author eb;	state Exp;
branches;
next	1.13;

1.13
date	2015.03.09.18.58.36;	author eb;	state Exp;
branches;
next	1.12;

1.12
date	2015.03.09.18.58.31;	author eb;	state Exp;
branches;
next	1.11;

1.11
date	2015.03.09.18.52.53;	author eb;	state Exp;
branches;
next	1.10;

1.10
date	2015.03.09.18.51.06;	author eb;	state Exp;
branches;
next	1.9;

1.9
date	2015.03.09.18.50.39;	author eb;	state Exp;
branches;
next	1.8;

1.8
date	2015.03.09.18.44.59;	author eb;	state Exp;
branches;
next	1.7;

1.7
date	2015.02.28.12.24.27;	author eb;	state Exp;
branches;
next	1.6;

1.6
date	2015.02.15.22.48.13;	author eb;	state Exp;
branches;
next	1.5;

1.5
date	2015.02.15.22.17.17;	author eb;	state Exp;
branches;
next	1.4;

1.4
date	2015.02.15.22.17.04;	author eb;	state Exp;
branches;
next	1.3;

1.3
date	2015.02.15.22.10.30;	author eb;	state Exp;
branches;
next	1.2;

1.2
date	2015.02.15.21.57.46;	author eb;	state Exp;
branches;
next	1.1;

1.1
date	2015.02.15.21.46.06;	author eb;	state Exp;
branches;
next	;


desc
@vim
@


1.18
log
@vim
@
text
@    use feature 'say';
    use utf8;
    use XML::LibXML;
    use Data::Printer;
    use Time::HiRes 'time';

    sub run_advanced_tests {

        my ( $source, $target, $results, $number ) = @@_;
        my ( $id, $adv_source, $adv_source_attr, $adv_target, $adv_target_attr,
            $desc, $error, $instruction );
        my ( @@id, @@adv_source, @@adv_source_attr, @@adv_target, @@adv_target_attr,
            @@desc, @@error, @@instruction );

        my $doc = XML::LibXML->new->parse_file("$DATA/advanced.xml");

        #    binmode( STDOUT, ":encoding(UTF-8)" );
        foreach my $TU ( $doc->findnodes('body/test-unit') ) {

            $id              = $TU->findvalue('./@@id');
            $adv_source      = $TU->findvalue('./source');
            $adv_source_attr = $TU->findvalue('./source/@@attr');
            $adv_target      = $TU->findvalue('./target');
            $adv_target_attr = $TU->findvalue('./target/@@attr');
            $desc            = $TU->findvalue('./desc');
            $error           = $TU->findvalue('./error');
            $speed           = $TU->findvalue('./speed');
            $instruction     = $TU->findvalue('./instruction');

            push( @@id,              $id );
            push( @@adv_source,      $adv_source );
            push( @@adv_source_attr, $adv_source_attr );
            push( @@adv_target,      $adv_target );
            push( @@adv_target_attr, $adv_target_attr );
            push( @@desc,            $desc );
            push( @@error,           $error );
            push( @@speed,           $speed );
            push( @@instruction,     $instruction );
        }

# my @@all = ( \@@id, \@@adv_source, \@@adv_source_attr, \@@adv_target, \@@adv_target_attr, \@@dec, \@@error, \@@speed )
        my $startTime;
        my $stopTime;

# Compile regexes for increased performance (saved 50 ms in one measurement for just 15-20 tests.)
#$adv_source = qr/$adv_source/;
#$adv_target = qr/$adv_target/;
        my $num_test = @@id;
        my $num      = @@{$number};

        my $ea = each_arrayref(
            \@@speed,           \@@adv_source,      \@@adv_target,
            \@@adv_source_attr, \@@adv_target_attr, \@@desc,
            \@@error,           \@@id,              \@@instruction
        );

        while (
            my (
                $speed,           $adv_source,      $adv_target,
                $adv_source_attr, $adv_target_attr, $desc,
                $error,           $id,              $instruction
            )
            = $ea->()
          )
        {

            $x++
              if ( defined $ARGV[2]
                && $ARGV[2] =~ /fast/
                && $speed =~ /[0-9]/
                && $speed >= 0.05 );

# ToDO: Add counting of number of matches, and raise exception if numbers indicate more than the single error reported.
# .
            $startTime = time();

            my $ab = each_arrayref( $source, $target, $number );

            while ( my ( $source, $target, $number ) = $ab->() ) {

                if (   ( $adv_source_attr =~ /invert/ )
                    && ( $adv_target_attr !~ /invert/ ) )
                {
                    if (   ( $source !~ /$adv_source/ )
                        && ( $target =~ /$adv_target/ ) )
                    {
                        ${$results}{"id=\"$number\""}{advanced}{$desc} +=
                          "$error";
                        say
"\n<p>\n$source<br>\n$target<br>\n$adv_source  ->  $adv_target<br>\n$desc ($error)\n<br>$instruction</p>";
                    }
                }
                elsif (( $adv_source_attr =~ /invert/ )
                    && ( $adv_target_attr =~ /invert/ ) )
                {
                    if (   ( $source !~ /$adv_source/ )
                        && ( $target !~ /$adv_target/ ) )
                    {
                        ${$results}{"id=\"$number\""}{advanced}{$desc} +=
                          "$error";
                        say
"\n<p>\n$source<br>\n$target<br>\n$adv_source  ->  $adv_target<br>\n$desc ($error)\n<br>$instruction</p>";
                    }
                }
                elsif (( $adv_source_attr !~ /invert/ )
                    && ( $adv_target_attr =~ /invert/ ) )
                {
                    if (   ( $source =~ /$adv_source/ )
                        && ( $target !~ /$adv_target/ ) )
                    {

                        ${$results}{"id=\"$number\""}{advanced}{$desc} +=
                          "$error";
                        say
"\n<p>\n$source<br>\n$target<br>\n$adv_source  ->  $adv_target<br>\n$desc ($error)\n<br>$instruction</p>";
                    }
                }
                else {
                    if (   ( $source =~ /$adv_source/ )
                        && ( $target =~ /$adv_target/ ) )
                    {
                        ${$results}{"id=\"$number\""}{advanced}{$desc} +=
                          "$error";
                        my $source_h      = $source;
                        my $target_h      = $target;
                        my $desc_h        = $desc;
                        my $error_h       = $error;
                        my $adv_source_h  = $adv_source;
                        my $adv_target_h  = $adv_target;
                        my $instruction_h = $instruction;

                        $source_h =~ s/($adv_source)/adv_source("$1")/ge;
                        $target_h =~ s/($adv_target)/adv_target("$1")/ge;

                        $instruction_h =~ s/(.*)/instruction("$1")/e;
                        $source_h =~ s/(.*)/source("$1")/e;
                        $target_h =~ s/(.*)/target("$1")/e;
                        $desc_h =~ s/(.*)/desc("$1")/e;
                        $error_h =~ s/(.*)/error("$1")/e;
                        $adv_source_h =~ s/(.*)/adv_source("$1")/e;
                        $adv_target_h =~ s/(.*)/adv_target("$1")/e;

                        say
"\n<p>\n$source_h<br>\n$target_h<br>\n$adv_source_h  ->  $adv_target_h<br>\n$desc_h ($error_h)\n<br>$instruction_h</p>";
                    }
                }
                $i += 1;
            }
            $stopTime = time();

#  printf("Test source: $adv_source target: $adv_target took %.5f seconds.\n",$stopTime - $startTime );
            if ( $stopTime - $startTime > 0.1 ) {
                warn
                  "Test $id about $adv_source / $adv_target is very slow:",
                  $stopTime - $startTime, "\nConsider optimizing.";
            }
        }
    }
    1;
@


1.17
log
@vim
@
text
@a102 1

a115 1

@


1.16
log
@vim
@
text
@d78 1
a78 1
 
d89 3
a91 3
                     say
"\n<p>\n$source_h<br>\n$target_h<br>\n$adv_source_h  ->  $adv_target_h<br>\n$desc_h ($error_h)\n<br>$instruction_h</p>";
              }
d101 3
a103 3
    say
"\n<p>\n$source_h<br>\n$target_h<br>\n$adv_source_h  ->  $adv_target_h<br>\n$desc_h ($error_h)\n<br>$instruction_h</p>";
           
d112 1
a112 1
                    
d115 4
a118 4
                           say
"\n<p>\n$source_h<br>\n$target_h<br>\n$adv_source_h  ->  $adv_target_h<br>\n$desc_h ($error_h)\n<br>$instruction_h</p>";
           
                      }
@


1.15
log
@vim
@
text
@d89 3
a91 1
                    }
d101 3
a103 1

d112 1
d115 4
a118 1
                    }
a146 1
                        say "<p>Plain source: ${source}test</p>";  # this works?
@


1.14
log
@vim
@
text
@a78 5
            # next 4 lines for testing string parsing error:
                 for $i ( 0 .. 30 ) {
                say "<p>$$source[$i]</p>";
                say "<p>$$target[$i]</p>";
            }
@


1.13
log
@vim
@
text
@d78 3
a80 1
            for $i ( 0 .. 20 ) {
@


1.12
log
@vim
@
text
@d8 1
a8 1
        
d78 4
a81 3
            for $i(0..20){
            say "<p>$$source[$i]</p>";
            say "<p>$$target[$i]</p>";}
d142 1
a142 1
say "<p>Plain source: ${source}test</p>"; # this works?
@


1.11
log
@vim
@
text
@d78 3
@


1.10
log
@vim
@
text
@d138 1
a138 1
say "<p>Plain source: $source</p>"; # this works?
@


1.9
log
@vim
@
text
@d138 1
a138 1
say "Plain source: $source"; # this works?
@


1.8
log
@vim
@
text
@d138 1
a138 1

@


1.7
log
@vim
@
text
@d125 2
a126 2
                        $source_h =~ s/($adv_source)/adv_source($1)/ge;
                        $target_h =~ s/($adv_target)/adv_target($1)/ge;
d128 7
a134 7
                        $instruction_h =~ s/(.*)/instruction($1)/e;
                        $source_h =~ s/(.*)/source($1)/e;
                        $target_h =~ s/(.*)/target($1)/e;
                        $desc_h =~ s/(.*)/desc($1)/e;
                        $error_h =~ s/(.*)/error($1)/e;
                        $adv_source_h =~ s/(.*)/adv_source($1)/e;
                        $adv_target_h =~ s/(.*)/adv_target($1)/e;
@


1.6
log
@vim
@
text
@a140 1

a141 1

@


1.5
log
@vim
@
text
@a39 2
        p @@speed;
        p @@instruction;
@


1.4
log
@vim
@
text
@d8 1
a8 1
        say $HTML;
@


1.3
log
@vim
@
text
@a6 10
    my @@span_tags =
      qw(instruction error adv_source adv_target source target wrong suggest type desc);

    for my $tag (@@span_tags) {
        no strict 'refs';
        *$tag = sub {
            "<SPAN CLASS='$tag'>@@_</SPAN>";
        };
    }

@


1.2
log
@vim
@
text
@a62 3
        my $red   = "\e[4;31m";
        my $reset = "\e[0m";

@


1.1
log
@vim
@
text
@a0 2
    package My::Advanced;

@
