head	1.38;
access;
symbols;
locks
	eb:1.38; strict;
comment	@# @;
expand	@o@;


1.38
date	2015.02.09.03.44.16;	author eb;	state Exp;
branches;
next	1.37;

1.37
date	2015.02.09.03.42.16;	author eb;	state Exp;
branches;
next	1.36;

1.36
date	2015.02.09.03.41.50;	author eb;	state Exp;
branches;
next	1.35;

1.35
date	2015.02.09.03.41.24;	author eb;	state Exp;
branches;
next	1.34;

1.34
date	2015.02.09.03.40.53;	author eb;	state Exp;
branches;
next	1.33;

1.33
date	2015.02.09.03.40.51;	author eb;	state Exp;
branches;
next	1.32;

1.32
date	2015.02.09.03.33.57;	author eb;	state Exp;
branches;
next	1.31;

1.31
date	2015.02.09.03.33.03;	author eb;	state Exp;
branches;
next	1.30;

1.30
date	2015.02.09.03.32.28;	author eb;	state Exp;
branches;
next	1.29;

1.29
date	2015.02.09.03.31.49;	author eb;	state Exp;
branches;
next	1.28;

1.28
date	2015.02.09.03.23.42;	author eb;	state Exp;
branches;
next	1.27;

1.27
date	2015.02.09.03.22.38;	author eb;	state Exp;
branches;
next	1.26;

1.26
date	2015.02.09.03.22.35;	author eb;	state Exp;
branches;
next	1.25;

1.25
date	2015.02.09.03.18.53;	author eb;	state Exp;
branches;
next	1.24;

1.24
date	2015.01.19.16.06.59;	author eb;	state Exp;
branches;
next	1.23;

1.23
date	2015.01.18.11.44.19;	author eb;	state Exp;
branches;
next	1.22;

1.22
date	2015.01.18.11.43.45;	author eb;	state Exp;
branches;
next	1.21;

1.21
date	2015.01.18.11.43.28;	author eb;	state Exp;
branches;
next	1.20;

1.20
date	2015.01.18.11.41.43;	author eb;	state Exp;
branches;
next	1.19;

1.19
date	2015.01.18.11.41.22;	author eb;	state Exp;
branches;
next	1.18;

1.18
date	2015.01.18.11.41.05;	author eb;	state Exp;
branches;
next	1.17;

1.17
date	2015.01.18.11.40.31;	author eb;	state Exp;
branches;
next	1.16;

1.16
date	2015.01.18.11.40.21;	author eb;	state Exp;
branches;
next	1.15;

1.15
date	2015.01.18.11.20.38;	author eb;	state Exp;
branches;
next	1.14;

1.14
date	2015.01.18.08.11.31;	author eb;	state Exp;
branches;
next	1.13;

1.13
date	2015.01.18.08.10.51;	author eb;	state Exp;
branches;
next	1.12;

1.12
date	2015.01.18.08.10.39;	author eb;	state Exp;
branches;
next	1.11;

1.11
date	2015.01.18.08.09.00;	author eb;	state Exp;
branches;
next	1.10;

1.10
date	2015.01.18.08.08.53;	author eb;	state Exp;
branches;
next	1.9;

1.9
date	2015.01.18.08.08.23;	author eb;	state Exp;
branches;
next	1.8;

1.8
date	2015.01.18.08.08.13;	author eb;	state Exp;
branches;
next	1.7;

1.7
date	2015.01.18.08.07.32;	author eb;	state Exp;
branches;
next	1.6;

1.6
date	2015.01.18.08.06.51;	author eb;	state Exp;
branches;
next	1.5;

1.5
date	2015.01.18.08.04.55;	author eb;	state Exp;
branches;
next	1.4;

1.4
date	2015.01.18.08.04.29;	author eb;	state Exp;
branches;
next	1.3;

1.3
date	2015.01.18.08.04.10;	author eb;	state Exp;
branches;
next	1.2;

1.2
date	2015.01.18.08.02.58;	author eb;	state Exp;
branches;
next	1.1;

1.1
date	2015.01.10.03.38.34;	author eb;	state Exp;
branches;
next	;


desc
@vim
@


1.38
log
@vim
@
text
@use feature 'say';
use Term::ANSIColor qw(:constants);
my ( $red, $reset ) = ( "\e[4;31m", "\e[0m" );

sub verify_number_array {

    my ($number) = @@_;
    my $test = @@{$number};
    my $error;
    for ( my $i = 0 ; $i < scalar $test ; $i++ ) {
        if ( $$number[$i] != $i + 1 ) {

            #  say "\$i is $i and number[$i] is $$number[$i]";
            $error++;
        }
    }
    if ( defined $error && $error >= 1 ) {
        if ( $HTML eq "true" ) {
            say
"$red\nYour XML's ID= numbers are not sequential.$reset\nThis is an indication that your XLF may have more serious problems!";
        }
    }
}
1;
@


1.37
log
@vim
@
text
@d18 1
a18 1
        if ( $html eq "true" ) {
@


1.36
log
@vim
@
text
@a0 2
package verify_number_array;

@


1.35
log
@vim
@
text
@d20 1
a20 1
        if ( $html = "true" ) {
@


1.34
log
@vim
@
text
@d3 1
a3 1
use 5.20.1;
a19 1
        no strict 'refs';
a23 1
        use strict 'refs';
a24 1

@


1.33
log
@vim
@
text
@d20 1
a20 1
no strict 'refs';
d25 1
a25 1
use strict 'refs';
@


1.32
log
@vim
@
text
@d20 1
d25 1
@


1.31
log
@vim
@
text
@d20 1
a20 1
        if ( $HTML = "true" ) {
@


1.30
log
@vim
@
text
@d1 1
a1 1
package verify_number_array
@


1.29
log
@vim
@
text
@d1 2
a2 1
packae 
@


1.28
log
@vim
@
text
@d1 1
@


1.27
log
@vim
@
text
@d18 1
a18 1
        if ( $html = "true" ) {
@


1.26
log
@vim
@
text
@d13 1
a13 1
              #  say "\$i is $i and number[$i] is $$number[$i]";
d18 2
a19 2
    if ($html = "true") {
        say 
d21 2
a22 1
   } }
@


1.25
log
@vim
@
text
@d18 2
a19 1
       say 
d21 1
a21 1
    }
@


1.24
log
@vim
@
text
@d18 1
a18 1
        warn
@


1.23
log
@vim
@
text
@d17 1
a17 1
    if ( $error >= 1 ) {
@


1.22
log
@vim
@
text
@a10 1
say $$number[$i];
@


1.21
log
@vim
@
text
@d11 1
a11 1
print $$number[$i];
@


1.20
log
@vim
@
text
@d11 1
@


1.19
log
@vim
@
text
@d7 1
a7 1
    my $number = @@_;
@


1.18
log
@vim
@
text
@d8 1
a8 1
    my $test = 0+@@{$number};
@


1.17
log
@vim
@
text
@d17 1
a17 1
    if ( defined $error ) {
@


1.16
log
@vim
@
text
@d7 1
a7 1
    my ($number) = @@_;
@


1.15
log
@vim
@
text
@d8 1
a8 1
    my $test = @@{$number};
@


1.14
log
@vim
@
text
@d13 1
a13 1
                say "\$i is $i and number[$i] is $$number[$i]";
@


1.13
log
@vim
@
text
@d13 1
a13 1
            #    say "\$i is $i and number[$i] is $$number[$i]";
d15 4
a18 3
        }}
        if ( defined $error ) {
            warn
d20 2
a21 2
        }
    
@


1.12
log
@vim
@
text
@d15 2
a16 3
        }
    
    if ( defined $error ) {
d20 1
a20 1
    }
@


1.11
log
@vim
@
text
@d16 2
a17 1
        if ( defined $error ) {
a20 1

@


1.10
log
@vim
@
text
@d11 1
a11 1
        if ( $$number[$i] !~ $i + 1 ) {
@


1.9
log
@vim
@
text
@d11 1
a11 1
        if ( $$number[$i] !~ $i ) {
a21 1
## Please see file perltidy.ERR
a22 1

@


1.8
log
@vim
@
text
@d12 1
d17 1
a17 1
     warn
d19 1
a19 1
}      
a20 1
 }
d22 1
d24 1
@


1.7
log
@vim
@
text
@d16 5
a20 1
        }
a21 2
    warn
"$red\nYour XML's ID= numbers are not sequential.$reset\nThis is an indication that your XLF may have more serious problems!";
@


1.6
log
@vim
@
text
@d11 1
a11 1
        if ( $$number[$i] !~ $i + 1 ) {
@


1.5
log
@vim
@
text
@d3 2
a4 1
my ($red, $reset) = ("\e[4;31m", "\e[0m");
d11 1
a11 3

        if ( $$number[$i] != $i + 1 ) {

d18 1
a18 1
   warn 
@


1.4
log
@vim
@
text
@d19 1
a19 1
    say
@


1.3
log
@vim
@
text
@d20 1
a20 1
"$redYour XML's ID= numbers are not sequential.$reset\nThis is an indication that your XLF may have more serious problems!";
@


1.2
log
@vim
@
text
@d20 1
a20 1
"$red$error segments are mislabeled.$reset\nThis is an indication that your XLF may have more serious problems!";
@


1.1
log
@vim
@
text
@d4 1
a4 1
sub verify_ids {
@
