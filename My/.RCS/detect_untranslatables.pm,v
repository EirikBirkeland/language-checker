head	1.10;
access;
symbols;
locks
	eb:1.10; strict;
comment	@# @;
expand	@o@;


1.10
date	2015.02.05.00.59.58;	author eb;	state Exp;
branches;
next	1.9;

1.9
date	2015.02.05.00.34.00;	author eb;	state Exp;
branches;
next	1.8;

1.8
date	2015.02.05.00.33.49;	author eb;	state Exp;
branches;
next	1.7;

1.7
date	2015.02.05.00.33.05;	author eb;	state Exp;
branches;
next	1.6;

1.6
date	2015.02.05.00.30.36;	author eb;	state Exp;
branches;
next	1.5;

1.5
date	2015.02.05.00.29.20;	author eb;	state Exp;
branches;
next	1.4;

1.4
date	2015.02.05.00.29.00;	author eb;	state Exp;
branches;
next	1.3;

1.3
date	2015.02.05.00.28.52;	author eb;	state Exp;
branches;
next	1.2;

1.2
date	2015.02.05.00.28.37;	author eb;	state Exp;
branches;
next	1.1;

1.1
date	2015.02.04.13.30.34;	author eb;	state Exp;
branches;
next	;


desc
@vim
@


1.10
log
@vim
@
text
@package detect_untrans;

use feature 'say';

sub detect_untrans {

    my ( $source, $target, $results ) = @@_;

    my ( %target_hash, %source_hash );

    # TODO: Further split @@source and @@target arrays by individual words.
    my @@source_words = split( ' ', $@@source );
    my @@target_words = split( ' ', $@@target );

# but a more elegant split method should be employed. perhaps use a lib that produces good results, or write a nice RegEx using regex101.com

    # Throw entire text into single variable
    my $corpus = join( ' ', @@source );

    # Count occurrences and throw into hash
    foreach $word (@@source_words) {
        $source_hash{$word} = () = $corpus =~ /$word/;
    }
    foreach $word (@@target_words) {
        $target_hash{$word} = () = $corpus =~ /$word/;
    }

    # Temp test variables
    $source_hash{Nexus} = 10;
    $target_hash{Nexus} = 8;

    # Comparison frequency of occurrence by percentage.
    if ( exists $target_hash{Nexus} ) {
        $percentage = $target_hash{Nexus} / $source_hash{Nexus};
        if ( ( $percentage >= 0.8 ) && ( $percentage <= 1.2 ) ) {
            say $percentage;
            say "hehe";

            #   my $input = <STDIN>;
            #   if $input eq "yes" {...} elsif $input eq "no" {...}

        }
    }
}
@


1.9
log
@vim
@
text
@d1 2
@


1.8
log
@vim
@
text
@d5 1
a5 1
   my ($source, $target, $results) = @@_;
d10 2
a11 2
    my @@source_words = split( ' ', @@source );
    my @@target_words = split( ' ', @@target );
@


1.7
log
@vim
@
text
@d5 2
@


1.6
log
@vim
@
text
@d8 2
a9 2
my @@source_words = split( ' ', @@source );
my @@target_words = split( ' ', @@target );
d13 1
a13 1
      # Throw entire text into single variable
@


1.5
log
@vim
@
text
@a6 1
## Please see file perltidy.ERR
d8 3
a10 2
    e . g . @@source_words = split( ' ', @@source ) e . g . @@target_words =
      split( ' ', @@source )
d14 1
a14 1
      $corpus = join( ' ', @@source );
@


1.4
log
@vim
@
text
@d6 3
a8 2
    
# TODO: Further split @@source and @@target arrays by individual words.
d10 2
a11 2
      split( ' ', @@source
      ) # but a more elegant split method should be employed. perhaps use a lib that produces good results, or write a nice RegEx using regex101.com
@


1.3
log
@vim
@
text
@d3 1
a3 5
sub detect_untrans { 



my ( %target_hash, %source_hash );
d5 2
d8 14
a21 15
e.g. @@source_words = split (' ', @@source)
e.g. @@target_words = split (' ', @@source) # but a more elegant split method should be employed. perhaps use a lib that produces good results, or write a nice RegEx using regex101.com

# Throw entire text into single variable
$corpus = join (' ', @@source);

# Count occurrences and throw into hash
foreach $word(@@source_words) {
$source_hash{$word} = () = $corpus =~ /$word/;
}
foreach $word(@@target_words) {
$target_hash{$word} = () = $corpus =~ /$word/;
}


d23 10
a32 10
# Temp test variables
$source_hash{Nexus} = 10;
$target_hash{Nexus} = 8;

# Comparison frequency of occurrence by percentage.
if ( exists $target_hash{Nexus} ) {
    $percentage = $target_hash{Nexus} / $source_hash{Nexus};
    if ( ( $percentage >= 0.8 ) && ( $percentage <= 1.2 ) ) {
        say $percentage;
        say "hehe";
d34 2
a35 2
        #   my $input = <STDIN>;
        #   if $input eq "yes" {...} elsif $input eq "no" {...}
d37 1
a38 1
}
@


1.2
log
@vim
@
text
@d3 1
a3 1
sub 
d41 1
@


1.1
log
@vim
@
text
@d2 5
@
