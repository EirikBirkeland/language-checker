head	1.91;
access;
symbols;
locks
	eb:1.91; strict;
comment	@# @;
expand	@o@;


1.91
date	2015.02.13.19.49.22;	author eb;	state Exp;
branches;
next	1.90;

1.90
date	2015.02.08.21.52.23;	author eb;	state Exp;
branches;
next	1.89;

1.89
date	2015.02.06.13.29.44;	author eb;	state Exp;
branches;
next	1.88;

1.88
date	2015.02.06.13.28.38;	author eb;	state Exp;
branches;
next	1.87;

1.87
date	2015.02.06.13.28.35;	author eb;	state Exp;
branches;
next	1.86;

1.86
date	2015.02.06.13.26.05;	author eb;	state Exp;
branches;
next	1.85;

1.85
date	2015.02.06.13.25.32;	author eb;	state Exp;
branches;
next	1.84;

1.84
date	2015.02.06.13.23.51;	author eb;	state Exp;
branches;
next	1.83;

1.83
date	2015.02.06.13.23.29;	author eb;	state Exp;
branches;
next	1.82;

1.82
date	2015.02.06.13.22.34;	author eb;	state Exp;
branches;
next	1.81;

1.81
date	2015.02.06.13.21.48;	author eb;	state Exp;
branches;
next	1.80;

1.80
date	2015.02.06.13.21.29;	author eb;	state Exp;
branches;
next	1.79;

1.79
date	2015.02.06.13.21.04;	author eb;	state Exp;
branches;
next	1.78;

1.78
date	2015.02.06.13.21.02;	author eb;	state Exp;
branches;
next	1.77;

1.77
date	2015.02.06.13.20.22;	author eb;	state Exp;
branches;
next	1.76;

1.76
date	2015.02.06.13.18.46;	author eb;	state Exp;
branches;
next	1.75;

1.75
date	2015.02.06.13.18.11;	author eb;	state Exp;
branches;
next	1.74;

1.74
date	2015.02.06.13.17.56;	author eb;	state Exp;
branches;
next	1.73;

1.73
date	2015.02.06.13.15.57;	author eb;	state Exp;
branches;
next	1.72;

1.72
date	2015.02.06.13.14.40;	author eb;	state Exp;
branches;
next	1.71;

1.71
date	2015.02.06.13.11.12;	author eb;	state Exp;
branches;
next	1.70;

1.70
date	2015.02.06.13.10.16;	author eb;	state Exp;
branches;
next	1.69;

1.69
date	2015.02.06.13.10.02;	author eb;	state Exp;
branches;
next	1.68;

1.68
date	2015.02.06.13.09.29;	author eb;	state Exp;
branches;
next	1.67;

1.67
date	2015.02.06.13.08.51;	author eb;	state Exp;
branches;
next	1.66;

1.66
date	2015.02.06.13.07.22;	author eb;	state Exp;
branches;
next	1.65;

1.65
date	2015.02.06.13.07.03;	author eb;	state Exp;
branches;
next	1.64;

1.64
date	2015.02.06.13.05.02;	author eb;	state Exp;
branches;
next	1.63;

1.63
date	2015.02.06.13.03.59;	author eb;	state Exp;
branches;
next	1.62;

1.62
date	2015.02.06.13.00.59;	author eb;	state Exp;
branches;
next	1.61;

1.61
date	2015.02.05.02.04.37;	author eb;	state Exp;
branches;
next	1.60;

1.60
date	2015.02.05.01.56.49;	author eb;	state Exp;
branches;
next	1.59;

1.59
date	2015.02.05.01.56.03;	author eb;	state Exp;
branches;
next	1.58;

1.58
date	2015.02.05.01.55.22;	author eb;	state Exp;
branches;
next	1.57;

1.57
date	2015.02.05.01.54.49;	author eb;	state Exp;
branches;
next	1.56;

1.56
date	2015.02.05.01.54.10;	author eb;	state Exp;
branches;
next	1.55;

1.55
date	2015.02.05.01.53.51;	author eb;	state Exp;
branches;
next	1.54;

1.54
date	2015.02.05.01.53.29;	author eb;	state Exp;
branches;
next	1.53;

1.53
date	2015.02.05.01.52.18;	author eb;	state Exp;
branches;
next	1.52;

1.52
date	2015.02.05.01.51.56;	author eb;	state Exp;
branches;
next	1.51;

1.51
date	2015.02.05.01.51.25;	author eb;	state Exp;
branches;
next	1.50;

1.50
date	2015.02.05.01.50.48;	author eb;	state Exp;
branches;
next	1.49;

1.49
date	2015.02.05.01.49.32;	author eb;	state Exp;
branches;
next	1.48;

1.48
date	2015.02.05.01.48.53;	author eb;	state Exp;
branches;
next	1.47;

1.47
date	2015.02.05.01.48.37;	author eb;	state Exp;
branches;
next	1.46;

1.46
date	2015.02.05.01.48.16;	author eb;	state Exp;
branches;
next	1.45;

1.45
date	2015.02.05.01.47.56;	author eb;	state Exp;
branches;
next	1.44;

1.44
date	2015.02.05.01.46.28;	author eb;	state Exp;
branches;
next	1.43;

1.43
date	2015.02.05.01.46.05;	author eb;	state Exp;
branches;
next	1.42;

1.42
date	2015.02.05.01.45.06;	author eb;	state Exp;
branches;
next	1.41;

1.41
date	2015.02.05.01.44.57;	author eb;	state Exp;
branches;
next	1.40;

1.40
date	2015.02.05.01.44.36;	author eb;	state Exp;
branches;
next	1.39;

1.39
date	2015.02.05.01.43.57;	author eb;	state Exp;
branches;
next	1.38;

1.38
date	2015.02.05.01.42.49;	author eb;	state Exp;
branches;
next	1.37;

1.37
date	2015.02.05.01.42.21;	author eb;	state Exp;
branches;
next	1.36;

1.36
date	2015.02.05.01.41.22;	author eb;	state Exp;
branches;
next	1.35;

1.35
date	2015.02.05.01.40.24;	author eb;	state Exp;
branches;
next	1.34;

1.34
date	2015.02.05.01.39.40;	author eb;	state Exp;
branches;
next	1.33;

1.33
date	2015.02.05.01.39.29;	author eb;	state Exp;
branches;
next	1.32;

1.32
date	2015.02.05.01.38.43;	author eb;	state Exp;
branches;
next	1.31;

1.31
date	2015.02.05.01.38.14;	author eb;	state Exp;
branches;
next	1.30;

1.30
date	2015.02.05.01.36.54;	author eb;	state Exp;
branches;
next	1.29;

1.29
date	2015.02.05.01.35.57;	author eb;	state Exp;
branches;
next	1.28;

1.28
date	2015.02.05.01.35.46;	author eb;	state Exp;
branches;
next	1.27;

1.27
date	2015.02.05.01.35.13;	author eb;	state Exp;
branches;
next	1.26;

1.26
date	2015.02.05.01.35.04;	author eb;	state Exp;
branches;
next	1.25;

1.25
date	2015.02.05.01.34.37;	author eb;	state Exp;
branches;
next	1.24;

1.24
date	2015.02.05.01.34.19;	author eb;	state Exp;
branches;
next	1.23;

1.23
date	2015.02.05.01.33.20;	author eb;	state Exp;
branches;
next	1.22;

1.22
date	2015.02.05.01.32.38;	author eb;	state Exp;
branches;
next	1.21;

1.21
date	2015.02.05.01.32.08;	author eb;	state Exp;
branches;
next	1.20;

1.20
date	2015.02.05.01.31.57;	author eb;	state Exp;
branches;
next	1.19;

1.19
date	2015.02.05.01.29.35;	author eb;	state Exp;
branches;
next	1.18;

1.18
date	2015.02.05.01.29.23;	author eb;	state Exp;
branches;
next	1.17;

1.17
date	2015.02.05.01.28.30;	author eb;	state Exp;
branches;
next	1.16;

1.16
date	2015.02.05.01.26.21;	author eb;	state Exp;
branches;
next	1.15;

1.15
date	2015.02.05.01.26.09;	author eb;	state Exp;
branches;
next	1.14;

1.14
date	2015.02.05.01.25.47;	author eb;	state Exp;
branches;
next	1.13;

1.13
date	2015.02.05.01.17.32;	author eb;	state Exp;
branches;
next	1.12;

1.12
date	2015.02.05.01.17.11;	author eb;	state Exp;
branches;
next	1.11;

1.11
date	2015.02.05.01.16.57;	author eb;	state Exp;
branches;
next	1.10;

1.10
date	2015.02.05.01.13.08;	author eb;	state Exp;
branches;
next	1.9;

1.9
date	2015.02.05.01.13.01;	author eb;	state Exp;
branches;
next	1.8;

1.8
date	2015.02.05.01.12.37;	author eb;	state Exp;
branches;
next	1.7;

1.7
date	2015.02.05.01.09.44;	author eb;	state Exp;
branches;
next	1.6;

1.6
date	2015.02.05.01.09.36;	author eb;	state Exp;
branches;
next	1.5;

1.5
date	2015.02.05.01.09.02;	author eb;	state Exp;
branches;
next	1.4;

1.4
date	2015.02.05.01.06.22;	author eb;	state Exp;
branches;
next	1.3;

1.3
date	2015.02.05.01.01.04;	author eb;	state Exp;
branches;
next	1.2;

1.2
date	2015.02.05.01.00.53;	author eb;	state Exp;
branches;
next	1.1;

1.1
date	2015.02.05.00.59.58;	author eb;	state Exp;
branches;
next	;


desc
@vim
@


1.91
log
@vim
@
text
@use feature 'say';

sub detect_untrans {
    my ( $source, $target, $results ) = @@_;

    my ( %target_hash, %source_hash );

    # TODO: Further split @@source and @@target arrays by individual words.
    my $source_text = join( ' ', @@$source );
    my $target_text = join( ' ', @@$target );
    my @@source_words = split( ' ', $source_text );
    my @@target_words = split( ' ', $target_text );

# but a more elegant split method should be employed. perhaps use a lib that produces good results, or write a nice RegEx using regex101.com

    # Remove periods and commas
    s/[,.]// foreach (@@source_words);
    s/[,.]// foreach (@@target_words);

    # Remove duplicates from array.
    @@source_words = uniq(@@source_words);
    @@target_words = uniq(@@source_words);

    # Remove unlikely candidates
    @@target_words = grep !/^[a-z]{0,5}$|^\w{0,2}$/, @@target_words;

    # Count occurrences and throw into hash
    foreach my $word (@@source_words) {
        $source_hash{$word} += () = $source_text =~ /\Q$word\E/g;
    }
    foreach my $word (@@target_words) {
        $target_hash{$word} += () = $target_text =~ /\Q$word\E/g;
    }

    # Compare frequency of occurrence by percentage.
    foreach my $word (@@source_words) {
        if ( ( exists $target_hash{$word} ) && ( $source_hash{$word} != 0 ) ) {
            $percentage = $target_hash{$word} / $source_hash{$word};
            if (   ( $percentage >= 0.7 )
                && ( $percentage <= 1.3 )
                && ( $percentage != 1 ) )
            {
                # Reformat number
                $percentage = sprintf( "%.1f", $percentage * 100 );
                say
"$percentage%: Source: $source_hash{$word} Target: $target_hash{$word}\t$word<br>";

                #      TODO: Add Accept / reject candidate

                #   my $input = <STDIN>;
                #  if $input eq "yes" {...} elsif $input eq "no" {...};
            }
        }
    }
}
1;
@


1.90
log
@vim
@
text
@d46 1
a46 1
"$percentage%: Source: $source_hash{$word} Target: $target_hash{$word}\t$word";
@


1.89
log
@vim
@
text
@d48 1
a48 1
        #      TODO: Add Accept / reject candidate
d50 2
a51 2
                  #   my $input = <STDIN>;
                  #  if $input eq "yes" {...} elsif $input eq "no" {...};
@


1.88
log
@vim
@
text
@d48 1
a48 1
              TODO: Add Accept / reject candidate
@


1.87
log
@vim
@
text
@d37 1
a37 1
        if (( exists $target_hash{$word}) && ($source_hash{$word} != 0)) {
d48 4
a51 3
TODO: Add Accept/reject candidate
                #   my $input = <STDIN>;
                #  if $input eq "yes" {...} elsif $input eq "no" {...};
@


1.86
log
@vim
@
text
@d37 1
a37 1
        if ( exists $target_hash{$word} ) {
@


1.85
log
@vim
@
text
@d48 1
@


1.84
log
@vim
@
text
@d35 1
a35 1
    # Comparison frequency of occurrence by percentage.
@


1.83
log
@vim
@
text
@d31 2
a32 2
    foreach my $word2 (@@target_words) {
        $target_hash{$word2} += () = $target_text =~ /\Q$word2\E/g;
@


1.82
log
@vim
@
text
@a3 1
    say "we're now in detect_untrans sub\n";
d17 2
a18 3
    
s/[,.]// foreach(@@source_words);
s/[,.]// foreach(@@target_words);
d20 1
a20 1
    # TODO: Remove duplicates from array.
d24 1
@


1.81
log
@vim
@
text
@d20 1
a20 6
#foreach (@@source_words) {
    #    s/[,.]//;
    #}
    foreach (@@target_words) {
        s/[,.]//;
    }
@


1.80
log
@vim
@
text
@d17 6
a22 4
# Remove periods and commas
    foreach (@@source_words) {
        s/[,.]//;
    }
@


1.79
log
@vim
@
text
@d17 1
a17 1
    # TODO: Remove duplicates from array.
d25 1
@


1.78
log
@vim
@
text
@d18 1
a18 1
     foreach (@@source_words) {
a26 2


@


1.77
log
@vim
@
text
@d18 1
a18 4
    @@source_words = uniq(@@source_words);
    @@target_words = uniq(@@source_words);

    foreach (@@source_words) {
d24 5
@


1.76
log
@vim
@
text
@d49 1
a49 1
"$percentage: Source: $source_hash{$word} Target: $target_hash{$word}\t$word";
@


1.75
log
@vim
@
text
@d46 3
a48 3
# Reformat number
$percentage = sprintf("%.3f", $percentage * 100);            
    say
@


1.74
log
@vim
@
text
@d46 2
a47 1
$percent_reformat = sprintf("%.3f", $percentage * 100);            
@


1.73
log
@vim
@
text
@d42 6
a47 2
            if ( ( $percentage >= 0.7 ) && ( $percentage <= 1.3 ) && ( $percentage != 1 )){
                say
@


1.72
log
@vim
@
text
@d42 1
a42 1
            if ( ( $percentage >= 0.7 ) && ( $percentage <= 1.3 ) ) {
@


1.71
log
@vim
@
text
@d21 8
a28 6
foreach(@@source_words){
s/[,.]//;
}
foreach(@@target_words){
s/[,.]//;
}
a29 1
    @@target_words = grep !/^[a-z]{0,5}$/, @@target_words;
d43 3
a45 1
                say "$percentage: Source: $source_hash{$word} Target: $target_hash{$word}\t$word";
d47 1
a47 1
              #  if $input eq "yes" {...} elsif $input eq "no" {...};
@


1.70
log
@vim
@
text
@d41 1
a41 1
            if ( ( $percentage >= 0.8 ) && ( $percentage <= 1.2 ) ) {
@


1.69
log
@vim
@
text
@d28 1
a28 2
    @@test = grep !/^[a-z]{0,5}$/, @@target_words;
    p @@test;
@


1.68
log
@vim
@
text
@d17 1
a17 1
    # TODO: Remove uniques from array.
@


1.67
log
@vim
@
text
@d22 1
a22 1
s/,//;
d25 1
a25 1
s/,//;
@


1.66
log
@vim
@
text
@d21 7
@


1.65
log
@vim
@
text
@d21 1
a21 1
    @@test = grep !/^[a-z]{0,3}$/, @@target_words;
@


1.64
log
@vim
@
text
@d21 1
a21 1
    @@test = grep !/^[a-z]{,3}$/, @@target_words;
@


1.63
log
@vim
@
text
@d21 2
a22 2
    @@target_words = grep !/^[a-z]{,3}$/, @@target_words;

@


1.62
log
@vim
@
text
@d21 1
a21 1
    @@target_words = grep { /^[a-z]{,3}$/ } @@target_words;
@


1.61
log
@vim
@
text
@d21 2
@


1.60
log
@vim
@
text
@a29 1
    # CONTINUE HERE, GOT SLEEPY XXX
@


1.59
log
@vim
@
text
@d23 1
a23 1
        $source_hash{$word} += () = $source_text =~ / \Q$word\E /g;
d26 1
a26 1
        $target_hash{$word2} += () = $target_text =~ / \Q$word2\E /g;
@


1.58
log
@vim
@
text
@d23 1
a23 1
        $source_hash{$word} += () = $source_text =~ /\Q$word\E/g;
d26 1
a26 1
        $target_hash{$word2} += () = $target_text =~ /\Q$word2\E/g;
@


1.57
log
@vim
@
text
@d34 1
a34 1
            if ( ( $percentage >= 0.8 ) || ( $percentage <= 1.2 ) ) {
@


1.56
log
@vim
@
text
@d19 1
a19 1
    @@target_word  = uniq(@@source_words);
@


1.55
log
@vim
@
text
@d35 1
a35 1
                say "$percentage: Source: $source_hash{$word} Target: $target_hash{$word}";
@


1.54
log
@vim
@
text
@d35 1
a35 1
                say "$percentage: Source: $source_hash{$word} Target: $target_hash{$word};
@


1.53
log
@vim
@
text
@d35 1
a35 2
                say $percentage;
                say "hehe";
@


1.52
log
@vim
@
text
@d38 1
a38 1
                if $input eq "yes" {...} elsif $input eq "no" {...};
@


1.51
log
@vim
@
text
@d31 9
a39 10
    foreach my $word(@@source_words){
    if ( exists $target_hash{$word} ) {
        $percentage = $target_hash{Nexus} / $source_hash{Nexus};
        if ( ( $percentage >= 0.8 ) && ( $percentage <= 1.2 ) ) {
            say $percentage;
            say "hehe";

            #   my $input = <STDIN>;
            if $input eq "yes" {...} elsif $input eq "no" {...}
}
@


1.50
log
@vim
@
text
@d31 1
a37 1
## Please see file perltidy.ERR
d40 1
a40 1

@


1.49
log
@vim
@
text
@d17 3
a19 4

# TODO: Remove uniques from array.
@@source_words = uniq(@@source_words);
@@target_word = uniq(@@source_words);
d28 1
a28 1
    
d32 8
a39 7
         $percentage = $target_hash{Nexus} / $source_hash{Nexus};
         if ( ( $percentage >= 0.8 ) && ( $percentage <= 1.2 ) ) {
             say $percentage;
             say "hehe";
    
               #   my $input = <STDIN>;
      if $input eq "yes" {...} elsif $input eq "no" {...}
a40 1
          }
d42 1
@


1.48
log
@vim
@
text
@d29 1
a29 8
p %target_hash;
   #p $source_hash; # doesn't work
   #p %target_hash; # works 

    # Temp test variables
    #    $source_hash{Nexus} = 10;
    #    $target_hash{Nexus} = 8;

d32 8
a39 8
    #if ( exists $target_hash{$word} ) {
    #     $percentage = $target_hash{Nexus} / $source_hash{Nexus};
    #     if ( ( $percentage >= 0.8 ) && ( $percentage <= 1.2 ) ) {
    #         say $percentage;
    #         say "hehe";
    #
    #            #   my $input = <STDIN>;
    #   if $input eq "yes" {...} elsif $input eq "no" {...}
d41 2
a42 2
    #      }
    #    }
@


1.47
log
@vim
@
text
@d29 1
a29 1
p %source_hash;
@


1.46
log
@vim
@
text
@a20 1
p @@source_words;
d29 1
a29 1

@


1.45
log
@vim
@
text
@d21 1
a21 1

@


1.44
log
@vim
@
text
@d17 4
a20 2
p @@source_words;
p @@target_words;
@


1.43
log
@vim
@
text
@d17 2
a18 1
p (@@source_words, $target_words);
@


1.42
log
@vim
@
text
@d17 3
d28 2
a29 2
   p $source_hash; # doesn't work
   p %target_hash; # works 
@


1.41
log
@vim
@
text
@d26 1
a26 1
   # p %target_hash; # works 
@


1.40
log
@vim
@
text
@d21 2
a22 2
    foreach my $word (@@target_words) {
        $target_hash{$word} += () = $target_text =~ /\Q$word\E/g;
@


1.39
log
@vim
@
text
@d10 1
a10 1
    my $lol_text = join( ' ', @@$source );
d18 2
a19 2
    foreach $word (@@source_words) {
        $source_hash{$word} += () = $lol_text =~ /\Q$word\E/g;
d21 1
a21 1
    foreach $word (@@target_words) {
@


1.38
log
@vim
@
text
@d10 1
a10 1
    my $source_text = join( ' ', @@$source );
d19 1
a19 1
        $source_hash{$word} += () = $source_text =~ /\Q$word\E/g;
@


1.37
log
@vim
@
text
@d25 1
a25 1
   # p $source_hash; # doesn't work
@


1.36
log
@vim
@
text
@d25 2
a26 3
    p $source_hash;

   p %target_hash;
@


1.35
log
@vim
@
text
@d27 1
a27 1
    # p %target_hash;
@


1.34
log
@vim
@
text
@a14 3
p $source_text;
    # p @@source_words;

d19 1
a19 1
        $source_hash{$word} += () = $source_text =~ /\Q$word\E/;
d22 1
a22 1
        $target_hash{$word} += () = $target_text =~ /\Q$word\E/;
@


1.33
log
@vim
@
text
@d16 1
a16 1
    p @@source_words;
@


1.32
log
@vim
@
text
@d4 1
a4 1
say "we're now in detect_untrans sub\n";
d12 2
a13 4
    my @@source_words = split( ' ', $source_text);
    my @@target_words = split( ' ', $target_text);  

  p @@source_words;
d15 2
d28 3
a30 2
p $source_hash;
# p %target_hash;
d33 2
a34 2
#    $source_hash{Nexus} = 10;
#    $target_hash{Nexus} = 8;
d37 9
a45 9
                                # CONTINUE HERE, GOT SLEEPY XXX 
   #if ( exists $target_hash{$word} ) {
   #     $percentage = $target_hash{Nexus} / $source_hash{Nexus};
   #     if ( ( $percentage >= 0.8 ) && ( $percentage <= 1.2 ) ) {
   #         say $percentage;
   #         say "hehe";
#
#            #   my $input = <STDIN>;
            #   if $input eq "yes" {...} elsif $input eq "no" {...}
d47 2
a48 2
  #      }
#    }
@


1.31
log
@vim
@
text
@d37 7
a43 7
   if ( exists $target_hash{$word} ) {
        $percentage = $target_hash{Nexus} / $source_hash{Nexus};
        if ( ( $percentage >= 0.8 ) && ( $percentage <= 1.2 ) ) {
            say $percentage;
            say "hehe";

            #   my $input = <STDIN>;
d46 2
a47 2
        }
    }
@


1.30
log
@vim
@
text
@d29 1
a29 1
p %target_hash;
@


1.29
log
@vim
@
text
@d22 1
a22 1
        $source_hash{$word} = () = $source_text =~ /\Q$word\E/;
d25 1
a25 1
        $target_hash{$word} = () = $target_text =~ /\Q$word\E/;
@


1.28
log
@vim
@
text
@d25 1
a25 1
        $target_hash{$word} = () = $target_text =~ /$word/;
@


1.27
log
@vim
@
text
@a20 1
$source_hash{test} = 5;
d22 1
a22 1
        $source_hash{$word} = () = $source_text =~ /$word/;
@


1.26
log
@vim
@
text
@d21 1
a21 1
say $source_hash{test} = 5;
@


1.25
log
@vim
@
text
@d29 1
a29 1
p %source_hash;
@


1.24
log
@vim
@
text
@d21 1
a21 1
$source_hash{test} = 5;
@


1.23
log
@vim
@
text
@d21 1
@


1.22
log
@vim
@
text
@d29 1
a29 1

@


1.21
log
@vim
@
text
@d12 2
a13 2
    my @@source_words = split( ' ', $source_words);
    my @@target_words = split( ' ', $target_words);  
@


1.20
log
@vim
@
text
@d27 4
a30 1
i
@


1.19
log
@vim
@
text
@d27 1
a27 1

d33 1
a33 1
    for $word(@@ # CONTINUE HERE, GOT SLEEPY XXX 
@


1.18
log
@vim
@
text
@d33 1
a33 1
    for $word(@@ 
@


1.17
log
@vim
@
text
@d33 2
a34 1
    if ( exists $target_hash{Nexus} ) {
@


1.16
log
@vim
@
text
@d10 2
a11 2
    my $source_words = join( ' ', @@$source );
    my $target_words = join( ' ', @@$target );
a19 3
    # Throw entire text into single variable
    my $corpus = join( ' ', @@source );

d22 1
a22 1
        $source_hash{$word} = () = $corpus =~ /$word/;
d25 1
a25 1
        $target_hash{$word} = () = $corpus =~ /$word/;
@


1.15
log
@vim
@
text
@d10 2
a11 2
    my $source_text = join( ' ', @@$source );
    my $target_text = join( ' ', @@$target );
@


1.14
log
@vim
@
text
@d10 2
a11 2
    my $source_words = join( ' ', @@$source );
    my $target_words = join( ' ', @@$target );
d15 1
a15 1
  p $source_words;
@


1.13
log
@vim
@
text
@d11 7
a17 2
    my $target_words = join( '\n', @@$target );
p $source_words;
@


1.12
log
@vim
@
text
@d10 1
a10 1
    my $source_words = join( "\n", @@$source );
@


1.11
log
@vim
@
text
@d10 1
a10 1
    my $source_words = join( '\n', @@$source );
@


1.10
log
@vim
@
text
@d10 3
a12 3
    my @@source_words = split( ' ', @@$source );
    my @@target_words = split( ' ', @@$target );
p @@source_words;
@


1.9
log
@vim
@
text
@d10 1
a10 1
    my @@source_words = split( ' ', $@@source );
@


1.8
log
@vim
@
text
@d10 1
a10 1
    my @@source_words = split( ' ', @@$source );
@


1.7
log
@vim
@
text
@d12 1
a12 1

@


1.6
log
@vim
@
text
@d4 1
a4 1
say "we're now in detect_untrans sub";
@


1.5
log
@vim
@
text
@d4 1
a4 1

@


1.4
log
@vim
@
text
@a0 2
package detect_untrans;

@


1.3
log
@vim
@
text
@d29 2
a30 2
    $source_hash{Nexus} = 10;
    $target_hash{Nexus} = 8;
@


1.2
log
@vim
@
text
@d45 1
@


1.1
log
@vim
@
text
@d12 2
a13 2
    my @@source_words = split( ' ', $@@source );
    my @@target_words = split( ' ', $@@target );
@
